
window.api = (function(){
  const sb = window.supabase;
  async function getMyProfile(){ const { data: { user } } = await sb.auth.getUser(); const { data, error } = await sb.from('profiles').select('*').eq('id', user.id).single(); if (error) throw error; return data; }
  async function updateMyProfile(values){ const { data: { user } } = await sb.auth.getUser(); const { error } = await sb.from('profiles').update(values).eq('id', user.id); if (error) throw error; return true; }
  async function _getUserIdByEmail(email){ const { data, error } = await sb.from('profiles').select('id').eq('email', email).maybeSingle(); if (error) throw error; if (!data) throw new Error('No profile for email'); return data.id; }
  async function getAttendanceRange(fromDate){ const { data: { user } } = await sb.auth.getUser(); const { data, error } = await sb.from('attendance').select('date,present').eq('user_id', user.id).gte('date', fromDate).order('date'); if (error) throw error; return data||[]; }
  async function markAttendance({email,date,present}){ const { data: me } = await sb.auth.getUser(); const user_id = await _getUserIdByEmail(email); const { error } = await sb.from('attendance').upsert({ user_id, date, present: !!present, created_by: me.user.id }, { onConflict: 'user_id,date' }); if (error) throw error; return true; }
  async function getRecentWorkouts(limit=5){ const { data: { user } } = await sb.auth.getUser(); const { data, error } = await sb.from('workouts').select('date,session_name,total_meters,main_set,rpe').eq('user_id', user.id).order('date',{ascending:false}).limit(limit); if (error) throw error; return data||[]; }
  async function listWorkouts(offset=0,limit=25){ const { data: { user } } = await sb.auth.getUser(); const { data, error } = await sb.from('workouts').select('*').eq('user_id', user.id).order('date',{ascending:false}).range(offset,offset+limit-1); if (error) throw error; return data||[]; }
  async function createWorkout(payload){ const { data: me } = await sb.auth.getUser(); const user_id = await _getUserIdByEmail(payload.email); const rec = { user_id, date: payload.date, session_name: payload.session_name||null, group_no: payload.group_no?parseInt(payload.group_no,10):null, total_meters: payload.total_meters?parseInt(payload.total_meters,10):null, main_set: payload.main_set||null, notes: payload.notes||null, rpe: payload.rpe?parseInt(payload.rpe,10):null, created_by: me.user.id }; const { error } = await sb.from('workouts').insert(rec); if (error) throw error; return true; }
  async function getPayments(months=6){ const { data: { user } } = await sb.auth.getUser(); const { data, error } = await sb.from('payments').select('period,status,amount').eq('user_id', user.id).order('period',{ascending:false}).limit(months); if (error) throw error; return data||[]; }
  async function recordPayment(p){ const user_id = await _getUserIdByEmail(p.email); const period = p.period+'-01'; const rec = { user_id, period, amount: p.amount?Number(p.amount):null, status: p.status, due_date: p.due_date||null, paid_on: p.paid_on||null }; const { error } = await sb.from('payments').upsert(rec,{ onConflict:'user_id,period' }); if (error) throw error; return true; }
  async function getProgress(){ const { data: { user } } = await sb.auth.getUser(); const { data, error } = await sb.from('progress').select('*').eq('user_id', user.id).order('skill'); if (error) throw error; return data||[]; }
  async function upsertProfile(p){ const rec = { email:p.email, full_name:p.full_name||null, role:p.role||'swimmer', squad_level:p.squad_level||'Beginner', sublevel:p.sublevel||'S3', group_no:p.group_no?parseInt(p.group_no,10):4 }; const { error } = await sb.from('profiles').upsert(rec,{ onConflict:'email' }); if (error) throw error; return true; }
  async function getRoster(q="",limit=50,offset=0){ let query = sb.from('profiles').select('id,email,full_name,squad_level,sublevel,group_no,role').order('full_name',{nullsFirst:true}); if (q){ query = query.or(`email.ilike.%${q}%,full_name.ilike.%${q}%`); } const { data, error } = await query.range(offset,offset+limit-1); if (error) throw error; return data||[]; }
  async function setRole(email,role){ const { error } = await sb.from('profiles').update({role}).eq('email',email); if (error) throw error; return true; }
  async function getVideosForGroup(group_no){ const { data, error } = await sb.from('videos').select('*').lte('group_min',group_no).gte('group_max',group_no).order('id',{ascending:false}).limit(12); if (error) throw error; return data||[]; }
  async function addVideo(v){ const rec = { youtube_id:v.youtube_id, title:v.title||null, group_min:v.group_min?parseInt(v.group_min,10):4, group_max:v.group_max?parseInt(v.group_max,10):0 }; const { error } = await sb.from('videos').insert(rec); if (error) throw error; return true; }
  async function seedVideosDefaults(){ const { error } = await sb.rpc('seed_videos_defaults'); if (error) throw error; return true; }
  async function seedSampleFor(email){ const { error } = await sb.rpc('seed_sample_for', { p_email: email }); if (error) throw error; return true; }
  return { getMyProfile, updateMyProfile, getAttendanceRange, markAttendance, getRecentWorkouts, listWorkouts, createWorkout, getPayments, recordPayment, getProgress, upsertProfile, getRoster, setRole, getVideosForGroup, addVideo, seedVideosDefaults, seedSampleFor };
})();
